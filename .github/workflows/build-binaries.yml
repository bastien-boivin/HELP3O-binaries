name: Build HELP3O Binaries

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    name: Build ${{ matrix.os }} Python ${{ matrix.python }}
    runs-on: ${{ matrix.os }}
    
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-13, macos-14, windows-latest]
        python: ['3.11', '3.12', '3.13']
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}
      
      # Linux: install gfortran
      - name: Install gfortran (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y gfortran
      
      # macOS: install gfortran via Homebrew
      - name: Install gfortran (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install gcc
          GCC_PREFIX="$(brew --prefix gcc)"
          GFORTRAN_BIN="$(ls "$GCC_PREFIX/bin" | grep -E '^gfortran-[0-9]+$' | head -n 1)"
          if [ -z "$GFORTRAN_BIN" ]; then
            echo "No gfortran executable found in $GCC_PREFIX/bin" >&2
            exit 1
          fi
          echo "$GCC_PREFIX/bin" >> "$GITHUB_PATH"
          echo "FC=$GCC_PREFIX/bin/$GFORTRAN_BIN" >> "$GITHUB_ENV"
          echo "F77=$GCC_PREFIX/bin/$GFORTRAN_BIN" >> "$GITHUB_ENV"
          echo "Using gfortran binary: $GCC_PREFIX/bin/$GFORTRAN_BIN"
      
      # Windows: install MinGW
      - name: Install MinGW (Windows)
        if: runner.os == 'Windows'
        run: |
          choco install mingw -y
          Add-Content $env:GITHUB_PATH 'C:\tools\mingw64\bin'
      
      # Install numpy
      - name: Install numpy
        run: |
          python -m pip install --upgrade pip
          pip install numpy

      # Additional tools required by the Meson backend used by f2py (Python >= 3.12)
      - name: Install Meson toolchain
        run: |
          pip install meson ninja
      
      # Build HELP3O
      - name: Build HELP3O extension
        run: |
          python build_extensions.py

      # Fix macOS binary to use @rpath instead of absolute paths
      - name: Fix macOS binary rpath
        if: runner.os == 'macOS'
        run: |
          # Get gcc library path and export it
          export GCC_PREFIX="$(brew --prefix gcc)"

          python << EOF
          import glob
          import subprocess
          import os

          # Find the compiled binary
          binaries = glob.glob("HELP3O.*.so")
          if not binaries:
              print("ERROR: No binary found")
              exit(1)

          binary = binaries[0]
          print(f"Processing binary: {binary}")

          # Get gcc prefix from environment
          gcc_prefix = os.environ.get('GCC_PREFIX', '').strip()
          if not gcc_prefix:
              print("ERROR: GCC_PREFIX not set")
              exit(1)

          print(f"GCC prefix: {gcc_prefix}")

          # Get list of linked libraries
          result = subprocess.run(['otool', '-L', binary], capture_output=True, text=True)
          print("\n=== Current dependencies ===")
          print(result.stdout)

          # Fix each GCC library dependency to use @rpath
          for line in result.stdout.split('\n'):
              line = line.strip()
              if '/gcc/' in line or 'libgfortran' in line or 'libquadmath' in line or 'libgcc_s' in line:
                  # Extract library path (before the version info in parentheses)
                  lib_path = line.split('(')[0].strip()
                  if lib_path and lib_path != binary + ':':
                      lib_name = os.path.basename(lib_path)
                      # Change to @rpath
                      new_path = f"@rpath/{lib_name}"
                      print(f"\nChanging: {lib_path}")
                      print(f"      to: {new_path}")
                      subprocess.run(['install_name_tool', '-change', lib_path, new_path, binary], check=True)

          # Add multiple rpaths to support different Mac configurations
          # This ensures the binary works on both Intel (/usr/local) and Apple Silicon (/opt/homebrew)
          rpaths_to_add = [
              f"{gcc_prefix}/lib/gcc/current",  # Current GCC libs (versioned symlink)
              f"{gcc_prefix}/lib",              # General GCC lib directory
              "/usr/local/opt/gcc/lib/gcc/current",  # Intel Mac Homebrew
              "/usr/local/opt/gcc/lib",              # Intel Mac Homebrew fallback
              "/opt/homebrew/opt/gcc/lib/gcc/current",  # Apple Silicon Homebrew
              "/opt/homebrew/opt/gcc/lib",              # Apple Silicon Homebrew fallback
          ]

          print("\n=== Adding rpaths ===")
          # Get existing rpaths once
          check_result = subprocess.run(['otool', '-l', binary], capture_output=True, text=True)
          existing_rpaths = check_result.stdout

          for rpath in rpaths_to_add:
              if rpath not in existing_rpaths:
                  print(f"Adding: {rpath}")
                  try:
                      result = subprocess.run(['install_name_tool', '-add_rpath', rpath, binary],
                                            capture_output=True, text=True)
                      if result.returncode != 0:
                          print(f"  Warning: {result.stderr.strip()}")
                  except Exception as e:
                      print(f"  Warning: Could not add {rpath}: {e}")
              else:
                  print(f"Already exists: {rpath}")

          # Verify the changes
          print("\n=== Final dependencies ===")
          result = subprocess.run(['otool', '-L', binary], capture_output=True, text=True)
          print(result.stdout)

          print("\n=== Configured rpaths ===")
          result = subprocess.run(['otool', '-l', binary], capture_output=True, text=True)
          in_rpath_section = False
          for line in result.stdout.split('\n'):
              if 'cmd LC_RPATH' in line:
                  in_rpath_section = True
              if in_rpath_section:
                  print(line)
                  if line.strip().startswith('cmdsize'):
                      in_rpath_section = False

          print("\nâœ“ Binary processed successfully")
          EOF

      # Rename the binary with a platform-specific suffix
      - name: Rename binary (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          python << 'EOF'
          import sys
          import glob
          from pathlib import Path
          import os
          
          binaries = glob.glob("HELP3O.*.so")
          if not binaries:
              print("ERROR: No binary found")
              sys.exit(1)

          src = Path(binaries[0])
          parts = src.name.split('.')
          if len(parts) < 3:
              print(f"Unexpected filename format: {src.name}")
              sys.exit(1)

          base = parts[0]
          python_tag = parts[1]
          suffix = src.suffix
          runner_os = os.environ.get("RUNNER_OS", "").lower()
          runner_arch = os.environ.get("RUNNER_ARCH", "").lower()
          arch_map = {"x64": "x86_64", "arm64": "arm64"}
          arch = arch_map.get(runner_arch, runner_arch or "unknown")

          dest = src
          if "darwin" in python_tag:
              normalized_tag = python_tag.replace("darwin", f"macosx_{arch}")
              dest = Path(f"{base}.{normalized_tag}{suffix}")
          elif "linux" not in python_tag:
              platform_tag = f"{runner_os}_{arch}"
              dest = Path(f"{base}.{python_tag}-{platform_tag}{suffix}")

          if dest != src:
              if dest.exists():
                  dest.unlink()
              src.rename(dest)
              print(f"Renamed {src} -> {dest}")
          else:
              print(f"Keeping existing filename: {src}")
          EOF
      
      - name: Rename binary (Windows)
        if: runner.os == 'Windows'
        run: |
          python -c "import glob; print(glob.glob('HELP3O.*.pyd'))"
      
      # Upload compiled artifacts
      - name: Upload binary artifact (Linux/macOS)
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: HELP3O.*.so
          if-no-files-found: error
      
      - name: Upload binary artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: HELP3O.*.pyd
          if-no-files-found: error

  release:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: build
    if: ${{ success() }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          TAG="v$(date -u +'%Y.%m')"
          if git rev-parse "refs/tags/${TAG}" >/dev/null 2>&1; then
            TAG="${TAG}-${GITHUB_RUN_NUMBER}"
          fi
          echo "tag=${TAG}" >> "${GITHUB_OUTPUT}"
          echo "name=HELP3O binaries ${TAG#v}" >> "${GITHUB_OUTPUT}"
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries
      
      - name: List packaged binaries
        run: |
          find binaries -type f
      
      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.name }}
          files: binaries/**/*
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
