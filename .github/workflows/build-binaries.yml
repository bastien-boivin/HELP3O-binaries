name: Build HELP3O Binaries

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    name: Build ${{ matrix.os }} Python ${{ matrix.python }}
    runs-on: ${{ matrix.os }}
    
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-13, macos-14, windows-latest]
        python: ['3.11', '3.12', '3.13']
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}
      
      # Linux: install gfortran
      - name: Install gfortran (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y gfortran
      
      # macOS: install gfortran via Homebrew
      - name: Install gfortran (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install gcc
          GCC_PREFIX="$(brew --prefix gcc)"
          GFORTRAN_BIN="$(ls "$GCC_PREFIX/bin" | grep -E '^gfortran-[0-9]+$' | head -n 1)"
          if [ -z "$GFORTRAN_BIN" ]; then
            echo "No gfortran executable found in $GCC_PREFIX/bin" >&2
            exit 1
          fi
          echo "$GCC_PREFIX/bin" >> "$GITHUB_PATH"
          echo "FC=$GCC_PREFIX/bin/$GFORTRAN_BIN" >> "$GITHUB_ENV"
          echo "F77=$GCC_PREFIX/bin/$GFORTRAN_BIN" >> "$GITHUB_ENV"
          echo "Using gfortran binary: $GCC_PREFIX/bin/$GFORTRAN_BIN"
      
      # Windows: install MinGW
      - name: Install MinGW (Windows)
        if: runner.os == 'Windows'
        run: |
          choco install mingw -y
          Add-Content $env:GITHUB_PATH 'C:\tools\mingw64\bin'
      
      # Install numpy
      - name: Install numpy
        run: |
          python -m pip install --upgrade pip
          pip install numpy

      # Additional tools required by the Meson backend used by f2py (Python >= 3.12)
      - name: Install Meson toolchain
        run: |
          pip install meson ninja
      
      # Build HELP3O
      - name: Build HELP3O extension
        run: |
          python build_extensions.py

      # Bundle GCC libraries with macOS binary (self-contained approach)
      - name: Bundle GCC libraries with macOS binary
        if: runner.os == 'macOS'
        run: |
          BINARY=$(ls HELP3O.*.so 2>/dev/null | head -n1)
          if [ -z "$BINARY" ]; then
            echo "ERROR: No binary found"
            exit 1
          fi

          echo "=== Binary: $BINARY ==="
          echo "=== Original dependencies ==="
          otool -L "$BINARY"

          # Create libs directory
          mkdir -p gcc_libs

          # Find GCC installation
          GCC_PREFIX="$(brew --prefix gcc)"
          GCC_LIB_DIR="$GCC_PREFIX/lib/gcc/current"

          echo ""
          echo "=== Bundling GCC libraries ==="

          # Copy all GCC runtime libraries
          for lib in libgfortran.5.dylib libquadmath.0.dylib libgcc_s.1.1.dylib libgcc_s.1.dylib; do
            if [ -f "$GCC_LIB_DIR/$lib" ]; then
              echo "Copying $lib..."
              cp "$GCC_LIB_DIR/$lib" gcc_libs/
            elif [ -f "$GCC_PREFIX/lib/$lib" ]; then
              echo "Copying $lib from $GCC_PREFIX/lib..."
              cp "$GCC_PREFIX/lib/$lib" gcc_libs/
            fi
          done

          # List bundled libraries
          echo ""
          echo "=== Bundled libraries ==="
          ls -lh gcc_libs/

          # Move libraries to same directory as binary (simpler for hydromodpy to handle)
          echo ""
          echo "=== Moving libraries to binary directory ==="
          mv gcc_libs/*.dylib .
          rmdir gcc_libs

          # Modify binary to use @loader_path (libraries in same directory as .so)
          echo ""
          echo "=== Modifying binary to use @loader_path ==="

          for lib in *.dylib; do
            libname=$(basename "$lib")
            echo "Processing $libname..."

            # Get current path from binary
            current_path=$(otool -L "$BINARY" | grep "$libname" | awk '{print $1}')

            if [ -n "$current_path" ]; then
              echo "  Changing: $current_path"
              echo "       to: @loader_path/$libname"
              install_name_tool -change "$current_path" "@loader_path/$libname" "$BINARY"
            fi
          done

          # Also fix inter-library dependencies
          echo ""
          echo "=== Fixing inter-library dependencies ==="
          for lib in *.dylib; do
            libname=$(basename "$lib")
            echo "Processing $libname..."

            # Change ID to @loader_path
            install_name_tool -id "@loader_path/$libname" "$lib"

            # Fix dependencies within the library
            otool -L "$lib" | grep -E 'libgfortran|libquadmath|libgcc_s' | awk '{print $1}' | while read dep; do
              depname=$(basename "$dep")
              if [ -f "$depname" ] && [ "$dep" != "@loader_path/$depname" ]; then
                echo "  Fixing dependency: $depname"
                install_name_tool -change "$dep" "@loader_path/$depname" "$lib"
              fi
            done
          done

          echo ""
          echo "=== Final binary dependencies ==="
          otool -L "$BINARY"

          echo ""
          echo "=== Final library dependencies ==="
          for lib in *.dylib; do
            echo "--- $(basename $lib) ---"
            otool -L "$lib"
          done

          echo ""
          echo "âœ“ GCC libraries bundled successfully"

      # Rename the binary with a platform-specific suffix
      - name: Rename binary (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          python << 'EOF'
          import sys
          import glob
          from pathlib import Path
          import os
          
          binaries = glob.glob("HELP3O.*.so")
          if not binaries:
              print("ERROR: No binary found")
              sys.exit(1)

          src = Path(binaries[0])
          parts = src.name.split('.')
          if len(parts) < 3:
              print(f"Unexpected filename format: {src.name}")
              sys.exit(1)

          base = parts[0]
          python_tag = parts[1]
          suffix = src.suffix
          runner_os = os.environ.get("RUNNER_OS", "").lower()
          runner_arch = os.environ.get("RUNNER_ARCH", "").lower()
          arch_map = {"x64": "x86_64", "arm64": "arm64"}
          arch = arch_map.get(runner_arch, runner_arch or "unknown")

          dest = src
          if "darwin" in python_tag:
              normalized_tag = python_tag.replace("darwin", f"macosx_{arch}")
              dest = Path(f"{base}.{normalized_tag}{suffix}")
          elif "linux" not in python_tag:
              platform_tag = f"{runner_os}_{arch}"
              dest = Path(f"{base}.{python_tag}-{platform_tag}{suffix}")

          if dest != src:
              if dest.exists():
                  dest.unlink()
              src.rename(dest)
              print(f"Renamed {src} -> {dest}")
          else:
              print(f"Keeping existing filename: {src}")
          EOF
      
      - name: Rename binary (Windows)
        if: runner.os == 'Windows'
        run: |
          python -c "import glob; print(glob.glob('HELP3O.*.pyd'))"
      
      # Upload compiled artifacts
      - name: Upload binary artifact (Linux/macOS)
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: |
            HELP3O.*.so
            *.dylib
          if-no-files-found: error
      
      - name: Upload binary artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: HELP3O.*.pyd
          if-no-files-found: error

  release:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: build
    if: ${{ success() }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          TAG="v$(date -u +'%Y.%m')"
          if git rev-parse "refs/tags/${TAG}" >/dev/null 2>&1; then
            TAG="${TAG}-${GITHUB_RUN_NUMBER}"
          fi
          echo "tag=${TAG}" >> "${GITHUB_OUTPUT}"
          echo "name=HELP3O binaries ${TAG#v}" >> "${GITHUB_OUTPUT}"
      
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries
      
      - name: List packaged binaries
        run: |
          find binaries -type f
      
      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.name }}
          files: binaries/**/*
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
