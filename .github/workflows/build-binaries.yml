name: Build HELP3O Binaries

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    name: Build ${{ matrix.os }} Python ${{ matrix.python }}
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-13, macos-14, windows-latest]
        python: ['3.11', '3.12', '3.13']

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python }}

      # Linux: install gfortran
      - name: Install gfortran (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y gfortran

      # macOS: install gfortran via Homebrew
      - name: Install gfortran (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install gcc
          GCC_PREFIX="$(brew --prefix gcc)"
          GFORTRAN_BIN="$(ls "$GCC_PREFIX/bin" | grep -E '^gfortran-[0-9]+$' | head -n 1)"
          if [ -z "$GFORTRAN_BIN" ]; then
            echo "No gfortran executable found in $GCC_PREFIX/bin" >&2
            exit 1
          fi
          echo "$GCC_PREFIX/bin" >> "$GITHUB_PATH"
          echo "FC=$GCC_PREFIX/bin/$GFORTRAN_BIN" >> "$GITHUB_ENV"
          echo "F77=$GCC_PREFIX/bin/$GFORTRAN_BIN" >> "$GITHUB_ENV"
          echo "Using gfortran binary: $GCC_PREFIX/bin/$GFORTRAN_BIN"

      # Windows: install MinGW
      - name: Install MinGW (Windows)
        if: runner.os == 'Windows'
        run: |
          choco install mingw -y
          Add-Content $env:GITHUB_PATH 'C:\tools\mingw64\bin'

      # Install numpy
      - name: Install numpy
        run: |
          python -m pip install --upgrade pip
          pip install numpy

      # Additional tools required by the Meson backend used by f2py (Python >= 3.12)
      - name: Install Meson toolchain
        run: |
          pip install meson ninja

      # Build HELP3O
      - name: Build HELP3O extension
        run: |
          python build_extensions.py

      # Bundle GCC libraries with macOS binary (self-contained approach)
      - name: Bundle GCC libraries with macOS binary
        if: runner.os == 'macOS'
        run: |
          BINARY=$(ls HELP3O.*.so 2>/dev/null | head -n1)
          if [ -z "$BINARY" ]; then
            echo "ERROR: No binary found"
            exit 1
          fi

          echo "=== Binary: $BINARY ==="
          echo "=== Original dependencies ==="
          otool -L "$BINARY"

          # Create libs directory
          mkdir -p gcc_libs

          # Find GCC installation
          GCC_PREFIX="$(brew --prefix gcc)"
          GCC_LIB_DIR="$GCC_PREFIX/lib/gcc/current"

          echo ""
          echo "=== Bundling GCC libraries ==="

          # Copy all GCC runtime libraries
          for lib in libgfortran.5.dylib libquadmath.0.dylib libgcc_s.1.1.dylib libgcc_s.1.dylib; do
            if [ -f "$GCC_LIB_DIR/$lib" ]; then
              echo "Copying $lib..."
              cp "$GCC_LIB_DIR/$lib" gcc_libs/
            elif [ -f "$GCC_PREFIX/lib/$lib" ]; then
              echo "Copying $lib from $GCC_PREFIX/lib..."
              cp "$GCC_PREFIX/lib/$lib" gcc_libs/
            fi
          done

          # List bundled libraries
          echo ""
          echo "=== Bundled libraries ==="
          ls -lh gcc_libs/

          # Move libraries to same directory as binary (simpler for hydromodpy to handle)
          echo ""
          echo "=== Moving libraries to binary directory ==="
          mv gcc_libs/*.dylib .
          rmdir gcc_libs

          # Modify binary to use @loader_path (libraries in same directory as .so)
          echo ""
          echo "=== Modifying binary to use @loader_path ==="

          for lib in *.dylib; do
            libname=$(basename "$lib")
            echo "Processing $libname..."

            # Get current path from binary
            current_path=$(otool -L "$BINARY" | grep "$libname" | awk '{print $1}')

            if [ -n "$current_path" ]; then
              echo "  Changing: $current_path"
              echo "       to: @loader_path/$libname"
              install_name_tool -change "$current_path" "@loader_path/$libname" "$BINARY"
            fi
          done

          # Also fix inter-library dependencies
          echo ""
          echo "=== Fixing inter-library dependencies ==="
          for lib in *.dylib; do
            libname=$(basename "$lib")
            echo "Processing $libname..."

            # Change ID to @loader_path
            install_name_tool -id "@loader_path/$libname" "$lib"

            # Fix dependencies within the library
            otool -L "$lib" | grep -E 'libgfortran|libquadmath|libgcc_s' | awk '{print $1}' | while read dep; do
              depname=$(basename "$dep")
              if [ -f "$depname" ] && [ "$dep" != "@loader_path/$depname" ]; then
                echo "  Fixing dependency: $depname"
                install_name_tool -change "$dep" "@loader_path/$depname" "$lib"
              fi
            done
          done

          echo ""
          echo "=== Final binary dependencies ==="
          otool -L "$BINARY"

          echo ""
          echo "=== Final library dependencies ==="
          for lib in *.dylib; do
            echo "--- $(basename $lib) ---"
            otool -L "$lib"
          done

          echo ""
          echo "✓ GCC libraries bundled successfully"

      # Package macOS binaries with bundled libraries into a tarball
      - name: Package macOS binary with libraries
        if: runner.os == 'macOS'
        run: |
          python << 'EOF'
          import sys
          import glob
          from pathlib import Path
          import os
          import tarfile

          binaries = glob.glob("HELP3O.*.so")
          if not binaries:
              print("ERROR: No binary found")
              sys.exit(1)

          src = Path(binaries[0])
          parts = src.name.split('.')
          if len(parts) < 3:
              print(f"Unexpected filename format: {src.name}")
              sys.exit(1)

          base = parts[0]
          python_tag = parts[1]
          suffix = src.suffix
          runner_arch = os.environ.get("RUNNER_ARCH", "").lower()
          arch_map = {"x64": "x86_64", "arm64": "arm64"}
          arch = arch_map.get(runner_arch, runner_arch or "unknown")

          # Rename binary with normalized tag
          if "darwin" in python_tag:
              normalized_tag = python_tag.replace("darwin", f"macosx_{arch}")
              binary_name = f"{base}.{normalized_tag}{suffix}"
          else:
              binary_name = src.name

          if binary_name != src.name:
              if Path(binary_name).exists():
                  Path(binary_name).unlink()
              src.rename(binary_name)
              print(f"Renamed {src.name} -> {binary_name}")

          # Create tarball with binary + dylibs
          dylibs = glob.glob("*.dylib")
          tarball_name = binary_name.replace('.so', '_bundle.tar.gz')

          print(f"\nCreating bundle: {tarball_name}")
          print(f"  Binary: {binary_name}")
          print(f"  Libraries: {', '.join([Path(d).name for d in dylibs])}")

          with tarfile.open(tarball_name, 'w:gz') as tar:
              tar.add(binary_name, arcname=Path(binary_name).name)
              for dylib in dylibs:
                  tar.add(dylib, arcname=Path(dylib).name)

          print(f"\n✓ Bundle created: {tarball_name}")

          # Also keep the standalone binary for backward compatibility
          print(f"✓ Standalone binary: {binary_name}")
          EOF

      # Rename binary for Linux (no bundling needed)
      - name: Rename binary (Linux)
        if: runner.os == 'Linux'
        run: |
          python << 'EOF'
          import sys
          import glob
          from pathlib import Path

          binaries = glob.glob("HELP3O.*.so")
          if not binaries:
              print("ERROR: No binary found")
              sys.exit(1)

          src = Path(binaries[0])
          # Linux binaries usually already have correct names from f2py
          print(f"Linux binary: {src.name}")
          EOF

      # Bundle MinGW runtime for Windows
      - name: Bundle MinGW runtime (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $bundleDir = "win_bundle"
          if (Test-Path $bundleDir) { Remove-Item $bundleDir -Recurse -Force }
          New-Item -ItemType Directory -Path $bundleDir | Out-Null

          $binary = Get-ChildItem -Filter "HELP3O*.pyd" | Select-Object -First 1
          if (-not $binary) {
            Write-Error "No HELP3O .pyd binary found"
            exit 1
          }
          Copy-Item $binary.FullName $bundleDir

          $mingw = "C:\tools\mingw64\bin"
          $dlls = @(
            "libgfortran-5.dll",
            "libquadmath-0.dll",
            "libgcc_s_seh-1.dll",
            "libwinpthread-1.dll"
          )

          foreach ($dll in $dlls) {
            $src = Join-Path $mingw $dll
            if (-not (Test-Path $src)) {
              Write-Error "Missing required runtime: $src"
              exit 1
            }
            Copy-Item $src $bundleDir
          }

          $zipPath = "HELP3O_win_bundle.zip"
          if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
          Compress-Archive -Path (Join-Path $bundleDir '*') -DestinationPath $zipPath -Force
          Write-Host "Windows bundle created: $zipPath"

      # Rename binary (Windows) – keep standalone .pyd for backward compatibility
      - name: List Windows binaries
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          Get-ChildItem HELP3O*.pyd | Select-Object -ExpandProperty Name

      # Upload compiled artifacts
      - name: Upload binary artifact (macOS)
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: |
            HELP3O.*_bundle.tar.gz
            HELP3O.*.so
          if-no-files-found: error

      - name: Upload binary artifact (Linux)
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: HELP3O.*.so
          if-no-files-found: error

      - name: Upload binary artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: binary-${{ matrix.os }}-py${{ matrix.python }}
          path: |
            HELP3O.*.pyd
            HELP3O_win_bundle.zip
          if-no-files-found: error

  release:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: build
    if: ${{ success() }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          TAG="v$(date -u +'%Y.%m')"
          if git rev-parse "refs/tags/${TAG}" >/dev/null 2>&1; then
            TAG="${TAG}-${GITHUB_RUN_NUMBER}"
          fi
          echo "tag=${TAG}" >> "${GITHUB_OUTPUT}"
          echo "name=HELP3O binaries ${TAG#v}" >> "${GITHUB_OUTPUT}"

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries

      - name: List packaged binaries
        run: |
          find binaries -type f

      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.name }}
          files: binaries/**/*
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}